<!DOCTYPE html>
<html>

<head>
	<meta charset='utf-8'>
	<title>Cargo-specification</title>
	<script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove'></script>
	<script class='remove'>
		async function loadRust() {
			//this is the function you call in 'preProcess', to load the highlighter
			const worker = await new Promise(resolve => {
				require(["core/worker"], ({ worker }) => resolve(worker));
			});
			const action = "highlight-load-lang";
			const langURL =
				"https://gistcdn.githack.com/mimoo/a9e28fc565dddb369477e8bd34e6a1ae/raw/d8a7057fe9c7140f7ef5972b333716d9933fa29b/hljs-rust.js";
			const propName = "hljsDefineRust"; // This funtion is defined in the highlighter being loaded
			const lang = "rust"; // this is the class you use to identify the language
			worker.postMessage({ action, langURL, propName, lang });
			return new Promise(resolve => {
				worker.addEventListener("message", function listener({ data }) {
					const { action: responseAction, lang: responseLang } = data;
					if (responseAction === action && responseLang === lang) {
						worker.removeEventListener("message", listener);
						resolve();
					}
				});
			});
		}


		async function loadProto() {
			//this is the function you call in 'preProcess', to load the highlighter
			const worker = await new Promise(resolve => {
				require(["core/worker"], ({ worker }) => resolve(worker));
			});
			const action = "highlight-load-lang";
			const langURL =
				"https://gistcdn.githack.com/mimoo/a9e28fc565dddb369477e8bd34e6a1ae/raw/555beea7387129c657c49d8616b778c67629b586/hljs-proto.js";
			const propName = "hljsDefineProto"; // This funtion is defined in the highlighter being loaded
			const lang = "proto"; // this is the class you use to identify the language
			worker.postMessage({ action, langURL, propName, lang });
			return new Promise(resolve => {
				worker.addEventListener("message", function listener({ data }) {
					const { action: responseAction, lang: responseLang } = data;
					if (responseAction === action && responseLang === lang) {
						worker.removeEventListener("message", listener);
						resolve();
					}
				});
			});
		}

		var respecConfig = {
			preProcess: [loadRust, loadProto],
			specStatus: "base",
			editors: [
				// 
				{
					name: "David Wong",
					url: "",
				},
				// 
			],
			github: "",
			shortName: "",
			//			format: "markdown",
		};
	</script>
</head>

<body>
	<section id="abstract">This specification describes how the command-line utility cargo-specification works.</section>

	<h1>Cargo-specification</h1>
<p>author: David Wong</p>
<h2>overview</h2>
<ol>
<li>parse command-line arguments</li>
<li>depending on the mode:
a. the <code>Build</code> mode builds the specification
b. the <code>Watch</code> mode builds the specification on every change
c. the CI mode builds the specification and errors out if it doesnâ€™t match the given output path
this is useful in CI to make sure that the latest specification
has been pushed to the repository</li>
<li>parse the Specification.toml file</li>
<li>retrieve the template</li>
<li>retrieve the content from all the files listed in the .toml</li>
<li>render the template</li>
<li>build the spec</li>
</ol>
<h2>toml_parser</h2>
<pre lang="rust"><code>/// A specification file contains a specification, as well as sections of (title, text)
#[derive(Serialize, Deserialize, Debug)]
pub struct Specification {
    /// information about a specification
    pub metadata: Metadata,
    /// configuration of the specification
    pub config: Config,
    /// files to use for the specification's content
    pub sections: HashMap&lt;String, String&gt;,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Config {
    /// main template file
    pub template: String,
}

/// Metadata about a specification
#[derive(Serialize, Deserialize, Debug)]
pub struct Metadata {
    /// Name of the specification
    pub name: String,
    /// A description
    pub description: String,
    /// Version of the spec
    pub version: Option&lt;String&gt;,
    /// Authors, if any
    pub authors: Vec&lt;String&gt;,
}
</code></pre>
<h2>Parser</h2>
<p>A specification is all the concatenated comments from a list of files.
The list of files is maintained by a <code>Specification.toml</code> file.</p>
<p>Below are the different structures that we use to organize the specification:</p>
<p>parsing is based on the extension of the file:</p>
<ul>
<li>for markdown files, we retrieve the entire content</li>
<li>for python files we look for comments starting with <code>#~</code></li>
<li>for other files we look for comments starting with <code>//~</code>
lines starting with <code>//~ spec:instruction</code> are specific instructions
a comment starting with <code>//~ spec:startcode</code> will print
every line afterwards, up until a <code>//~ spec:endcode</code> statement</li>
</ul>


</body>

</html>